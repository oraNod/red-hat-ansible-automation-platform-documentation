# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2021, Red Hat Inc.
# This file is distributed under the same license as the Automation Controller API Guide package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: Automation Controller API Guide 4.2.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-05-10 17:06+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../source/access_resources.rst:3
msgid "Access Resources"
msgstr "リソースへのアクセス"

#: ../../source/access_resources.rst:8
msgid "Traditionally, |at| uses a primary key to access individual resource objects. Starting in 3.2 and API v2, the named URL feature allows you to access controller resources via resource-specific human-readable identifiers. In |at| versions prior to 3.2, the only way of accessing a resource object without auxiliary query string is via resource primary key number, for example, via URL path: ``/api/v2/hosts/2/``. Now, you can use a named URL to do the same thing, for example, via URL path ``/api/v2/hosts/host_name++inv_name++org_name/``."
msgstr "これまでは、|at| ではプライマリーキーを使用して個別のリソースオブジェクトにアクセスしていました。3.2 と API v2 からは、名前付き URL 機能を使用することで、リソース固有の人間が判読可能な識別子を使用してコントローラーリソースにアクセスができるようになりました。|at| 3.2 より前のバージョンでは、補助クエリー文字列なしでリソースオブジェクトにアクセスする唯一の方法は、``/api/v2/hosts/2/`` といった URL パス経由によるリソースのプライマリーキー番号でした。これが、``/api/v2/hosts/host_name++inv_name++org_name/`` といった URL パス経由による名前付き URL で同じことができるようになっています。"

#: ../../source/access_resources.rst:11
msgid "Configuration Settings"
msgstr "設定方法"

#: ../../source/access_resources.rst:13
msgid "There are two named-URL-related configuration settings available under ``/api/v2/settings/named-url/``:"
msgstr "``/api/v2/settings/named-url/`` 下には、2 つの名前付き URL 関連の設定があります。"

#: ../../source/access_resources.rst:15
msgid "``NAMED_URL_FORMATS`` and ``NAMED_URL_GRAPH_NODES``"
msgstr "``NAMED_URL_FORMATS`` および ``NAMED_URL_GRAPH_NODES``"

#: ../../source/access_resources.rst:17
msgid "``NAMED_URL_FORMATS`` is a read only key-value pair list of all available named URL identifier formats. A typical ``NAMED_URL_FORMATS`` looks like this:"
msgstr "``NAMED_URL_FORMATS`` は、読み取り専用のキーと値のペアのリストで、名前付き URL 識別子の利用可能なフォーマットがすべて含まれます。一般的な ``NAMED_URL_FORMATS`` は、以下のようになります。"

#: ../../source/access_resources.rst:43
msgid "For each item in ``NAMED_URL_FORMATS``, the key is the API name of the resource to have named URL, the value is a string indicating how to form a human-readable unique identifier for that resource. ``NAMED_URL_FORMATS`` exclusively lists every resource that can have named URL, any resource not listed there has no named URL. If a resource can have named URL, its objects should have a named_url field which represents the object-specific named URL. That field should only be visible under detail view, not list view. You can access specified resource objects using accurately generated named URL. This includes not only the object itself but also its related URLs. For example, if ``/api/v2/res_name/obj_slug/`` is valid, ``/api/v2/res_name/obj_slug/related_res_name/`` should also be valid."
msgstr "``NAMED_URL_FORMATS`` 内の各アイテムでは、名前付き URL を持つリソースの API 名がキーになり、そのリソースに対する人間が判読可能な識別子を形成する方法を示す文字列が値になります。``NAMED_URL_FORMATS`` には、名前付き URL を指定可能なすべてのリソースが一覧表示され、ここに一覧表示されないリソースには名前付き URL はありません。あるリソースが名前付き URL を指定できる場合は、そのオブジェクトにはオブジェクト固有の名前付き URL を表す named_url フィールドが含まれます。このフィールドは、一覧ビューではなく、詳細ビューでのみ表示可能です。生成された名前付き URL を正確に使用することで、指定されたリソースオブジェクトにアクセスできます。これはオブジェクト自体だけではなく、その関連 URL も含まれます。たとえば、``/api/v2/res_name/obj_slug/`` が有効であれば、``/api/v2/res_name/obj_slug/related_res_name/`` も有効になります。"

#: ../../source/access_resources.rst:45
msgid "``NAMED_URL_FORMATS`` are instructive enough to compose human-readable unique identifier and named URL themselves. For ease-of-use, every object of a resource that can have named URL will have a related field ``named_url`` that displays that object's named URL. You can copy and paste that field for your own custom use. Also refer to the help text of API browser if a resource object has named URL for further guidance."
msgstr "``NAMED_URL_FORMATS`` では、人間が判読可能な一意の識別子と名前付き URL 自体を構成しやすくなっています。名前付き URL を持つことが可能なリソースのオブジェクトには関連フィールドである ``named_url`` があり、これはそのオブジェクトの名前付き URL を表示します。このフィールドをコピーして貼り付けることで、カスタム使用することが可能です。リソースオブジェクトに名前付き URL がある場合は、詳細について API ブラウザーのヘルプテキストを参照することもできます。"

#: ../../source/access_resources.rst:47
msgid "Suppose you want to manually determine the named URL for a label with ID 5. A typical procedure of composing a named URL for this specific resource object using ``NAMED_URL_FORMATS`` is to first look up the labels field of ``NAMED_URL_FORMATS`` to get the identifier format ``<name>++<organization.name>``:"
msgstr "ID 5 のラベルについて、名前付き URL を手動で決定するとします。その場合、``NAMED_URL_FORMATS`` を使用してこのリソースオブジェクトの名前付き URL を構成するには、``NAMED_URL_FORMATS`` のラベルフィールドで、``<name>++<organization.name>`` の識別子フォーマットを確認します。"

#: ../../source/access_resources.rst:49
msgid "The first part of the URL format is ``<name>``, which indicates that the label resource detail can be found in ``/api/v2/labels/5/``, and look for ``name`` field in returned JSON. Suppose you have the ``name`` field with value 'Foo', then the first part of the unique identifier is **Foo**."
msgstr "URL フォーマットの最初の部分は ``<name>`` で、これはラベルリソースの詳細が ``/api/v2/labels/5/`` にあることを示し、返された JSON で ``name`` フィールドを確認します。``name`` フィールドの値が 'Foo' だったとすると、一意の識別子の最初の部分は **Foo** となります。"

#: ../../source/access_resources.rst:50
msgid "The second part of the format are double pluses ++. That is the delimiter that separates different parts of a unique identifier. Append them to the unique identifier to get **Foo++**"
msgstr "フォーマットの 2 番目の部分は、プラス記号 2 つである ++ となります。これは識別子の個別部分を分ける区切り記号です。これを識別子に追記して **Foo++** とします。"

#: ../../source/access_resources.rst:51
msgid "The third part of the format is ``<organization.name>``, which indicates that field is not in the current label object under investigation, but in an organization which the label object points to. Thus, as the format indicates, look up the organization in the related field of current returned JSON. That field may or may not exist. If it exists, follow the URL given in that field, for example, ``/api/v2/organizations/3/``, to get the detail of the specific organization, extract its ``name`` field, for example, 'Default', and append it to our current unique identifier. Since ``<organizations.name>`` is the last part of format, thus, generating the resulting named URL: ``/api/v2/labels/Foo++Default/``.  In the case where organization does not exist in related field of the label object detail, append an empty string instead, which essentially does not alter the current identifier. So ``Foo++`` becomes the final unique identifier and the resulting generated named URL becomes ``/api/v2/labels/Foo++/``."
msgstr "フォーマットの 3 番目の部分は ``<organization.name>`` で、これはフィールドは現在調べているラベルオブジェクトにはないものの、ラベルオブジェクトが指す組織内にあることを示します。つまり、フォーマットが示すように、現在返されている JSON 内の関連フィールドで組織を検索します。このフィールドは、ある場合とない場合があります。存在する場合は、そのフィールドにある URL、たとえば ``/api/v2/organizations/3/`` に従い、特定の組織の詳細を取得し、 'Default' というようなその ``name`` フィールドを抽出して、それを現行の一意の識別子に加えます。``<organizations.name>`` はフォーマットの最後の部分であることから、生成される名前付き URL は ``/api/v2/labels/Foo++Default/`` となります。ラベルオブジェクト詳細の関連フィールドに組織が存在しない場合は、空の文字列を追記するので、実際には現行の識別子からは変更なしになります。このため、``Foo++`` が最後の一意の識別子となり、生成される名前付き URL は、``/api/v2/labels/Foo++/`` となります。"

#: ../../source/access_resources.rst:53
msgid "An important aspect of generating a unique identifier for named URL has to do with reserved characters. Because the identifier is part of a URL, the following reserved characters by URL standard is encoded by percentage symbols: ``;/?:@=&[]``. For example, if an organization is named ``;/?:@=&[]``, its unique identifier should be ``%3B%2F%3F%3A%40%3D%26%5B%5D``. Another special reserved character is ``+``, which is not reserved by URL standard but used by named URL to link different parts of an identifier. It is encoded by ``[+]``. For example, if an organization is named ``[+]``, its unique identifier is ``%5B[+]%5D``, where original ``[`` and ``]`` are percent encoded and ``+`` is converted to ``[+]``."
msgstr "名前付き URL の一意の識別子生成における重要な側面の 1 つは予約文字です。識別子は URL の一部であるため、``;/?:@=&[]`` などのURL 標準の予約文字は、パーセント記号でエンコードされます。たとえば、組織の名前が ``;/?:@=&[]`` であったとすると、一意の識別子は ``%3B%2F%3F%3A%40%3D%26%5B%5D`` となります。もう 1 つの特別な予約文字は ``+`` で、これは URL 標準ではありませんが、識別子の別の部分にリンクするために名前付き URL で使用されます。``[+]`` でエンコードされ、たとえば組織名が ``[+]`` の場合、一意識別子は ``%5B[+]%5D`` となります。この場合、元の ``[`` と ``]`` はパーセントにエンコードされ、``+``は ``[+]`` に変換されています。"

#: ../../source/access_resources.rst:55
msgid "Although ``NAMED_URL_FORMATS`` cannot be manually modified, modifications do occur automatically and expanded over time, reflecting underlying resource modification and expansion. Consult the ``NAMED_URL_FORMATS`` on the same cluster where you want to use the named URL feature."
msgstr "``NAMED_URL_FORMATS`` は手動では変更できませんが、自動で変更され、時間の経過とともに拡張されて、基礎となるリソースの変更および拡張を反映します。名前付き URL 機能を使用する同じクラスターの ``NAMED_URL_FORMATS`` を参考にしてください。"

#: ../../source/access_resources.rst:57
msgid "``NAMED_URL_GRAPH_NODES`` is another read-only list of key-value pairs that exposes the internal graph data structure used to manage named URLs. This is not intended to be human-readable but should be used for programmatically generating named URLs. An example script for generating named URL given the primary key of arbitrary resource objects that can have a named URL, using info provided by ``NAMED_URL_GRAPH_NODES``, can be found in GitHub at https://github.com/ansible/awx/blob/devel/tools/scripts/pk_to_named_url.py."
msgstr "``NAMED_URL_GRAPH_NODES`` は、読み取り専用のキーと値がペアになったもう 1 つの一覧で、名前付き URL の管理に使用する内部のグラフデータ構造を公開します。これは人間が判読することを目的としていませんが、プログラムで生成される名前付き URL で使用されるはずです。``NAMED_URL_GRAPH_NODES`` が提供する情報を使用して、任意のリソースオブジェクトのプライマリーキーに名前付きの URL を指定できる、名前付き URL の生成スクリプト例は、GitHub (https://github.com/ansible/awx/blob/devel/tools/scripts/pk_to_named_url.py) で参照できます。"

#: ../../source/access_resources.rst:60
msgid "Identifier Format Protocol"
msgstr "識別子フォーマットのプロトコル"

#: ../../source/access_resources.rst:62
msgid "Resources are identifiable by their unique keys, which are basically tuples of resource fields. Every resource is guaranteed to have its primary key number alone as a unique key, but there might be multiple other unique keys. A resource can generate an identifier format thus, have a named URL if it contains at least one unique key that satisfies the rules below:"
msgstr "リソースは、基本的にはリソースフィールドのタプルであるそれらの一意のキーで特定することができます。各リソースには一意のキーとしてのプライマリーキー番号が必ずありますが、他の複数の一意のキーが存在する場合もあります。リソースは識別子フォーマットを生成することが可能で、以下のルールのいずれかを満たす一意のキーが少なくとも 1 つある場合は、名前付き URL を持つことができます。"

#: ../../source/access_resources.rst:64
msgid "The key must contain only fields that are either the ``name`` field, or text fields with a finite number of possible choices (like credential type resource's ``kind`` field)."
msgstr "キーには、``name`` フィールド、または (認証タイプリソースの ``kind`` フィールドのように) 有限数の選択肢のあるテキストフィールドのいずれかのみが含まれること。"

#: ../../source/access_resources.rst:66
msgid "The only allowed exceptional fields that breaks rule #1 is a many-to-one related field relating to a resource other than itself, which is also allowed to have a slug."
msgstr "上記のルール 1 の唯一の例外フィールドは、リソース自体以外に関連する多対 1 の関連フィールドで、これはスラグを持つことが可能です。"

#: ../../source/access_resources.rst:68
msgid "Suppose there are resources ``Foo`` and ``Bar``, both ``Foo`` and ``Bar`` contain a ``name`` field and a ``choice`` field that can only have value 'yes' or 'no'. Additionally, resource ``Foo`` contains a many-to-one field (a foreign key) relating to ``Bar``, e.g. ``fk``. ``Foo`` has a unique key tuple (``name``, ``choice``, ``fk``) and ``Bar`` has a unique key tuple (``name``, ``choice``). ``Bar`` can have named URL because it satisfies rule #1 above. ``Foo`` can also have named URL, even though it breaks rule #1, the extra field breaking rule #1 is the ``fk`` field, which is many-to-one-related to ``Bar`` and ``Bar`` can have named URL."
msgstr "``Foo`` と ``Bar`` のリソースがあり、その ``Foo`` と ``Bar`` の両方に ``name`` フィールドと ``choice`` フィールドが含まれるとします。これらのフィールドの値には「yes」または「no」のいずれかのみ指定できます。また、リソース ``Foo`` には、``fk`` のような ``Bar`` に関連する多対一のフィールド (外部キー) が含まれます。``Foo`` には一意のキータプル (``name``、``choice``、``fk``) があり、``Bar`` には一意のキータプル (``name``、``choice``) があります。``Bar`` は上記のルール 1 を満たしているため、名前付き URL を指定できます。``Foo`` はルール 1 を満たしていませんが、名前付き URL を指定できます。ルール 1 を違反している余分なフィールドは ``fk`` フィールドで、これが ``Bar`` に関連する多対一であり、``Bar`` に名前付き URL を指定できるためです。"

#: ../../source/access_resources.rst:70
msgid "For resources satisfying rule #1 above, their human-readable unique identifiers are combinations of foreign key fields, delimited by ``+``. In specific, resource ``Bar`` in the above example will have slug format ``<name>+<choice>``. Note the field order matters in slug format: ``name`` field always comes first if present, following by all the rest fields arranged in lexicographic order of field name. For example, if Bar also has an ``a_choice`` field satisfying rule #1 and the unique key becomes (``name``, ``choice``, ``a_choice``), its slug format becomes ``<name>+<a_choice>+<choice>``."
msgstr "上記のルール 1 の条件を満たしているリソースの場合、人間が判読可能な一意の識別子は、``+`` で区切られた外部キーフィールドの組み合わせになります。上記のリソース ``Bar`` の場合は、スラグフォーマット ``<name>+<choice>`` になります。スラグフォーマットでは、フィールドの順番が重要であることに注意してください。``name`` フィールドがある場合はこれが常に最初にきて、他のフィールド名が辞書的順序で続きます。たとえば、Bar にルール 1 を満たす ``a_choice`` フィールドもあり、一意のキーが (``name``、``choice``、``a_choice``) になったとすると、スラグフォーマットは ``<name>+<a_choice>+<choice>`` となります。"

#: ../../source/access_resources.rst:72
msgid "For resources satisfying rule #2 above, if traced back via the extra foreign key fields, the result is a tree of resources that all together identify objects of that resource. In order to generate identifier format, each resource in the traceback tree generates its own part of standalone format in the way previously described, using all fields but the foreign keys. Finally all parts are combined by ``++`` in the following order:"
msgstr "上記のルール 2 を満たすリソースの場合、新たな外部キーのフィールド経由でトレースバックした場合、結果はそのリソースのオブジェクトを一緒になって特定するリソースのツリーになります。識別子フォーマットを生成するために、トレースバックツリー内の各リソースは、外部キーを除くすべてのフィールドを使って、上記で説明した方法で自分の部分のスタンドアロンフォーマットを生成します。そして最後にすべての部分が以下の順番で ``++`` を使って結合されます。"

#: ../../source/access_resources.rst:74
msgid "Put stand-alone format as the first identifier component."
msgstr "識別子の最初のコンポーネントとしてスタンドアロンフォーマットが置かれます。"

#: ../../source/access_resources.rst:75
msgid "Recursively generate unique identifiers for each resource. The underlying resource is pointing to using a foreign key (a child of a traceback tree node)."
msgstr "各リソースの一意の識別子が再帰的に生成されます。基礎となるリソースは、外部キー (トレースバックツリーノードの子) の使用を指します。"

#: ../../source/access_resources.rst:76
msgid "Treat generated unique identifiers as the rest of the identifier components. Sort them in lexicographic order of corresponding foreign keys."
msgstr "生成された一意の識別子は、残りの識別子コンポーネントとして扱われます。対応する外部キーの辞書的順序で並び替えられます。"

#: ../../source/access_resources.rst:77
msgid "Combine all components together using ``++`` to generate the final identifier format."
msgstr "``++`` で全コンポーネントを結合し、最終的な識別子フォーマットを生成します。"

#: ../../source/access_resources.rst:79
msgid "In reference to the example above, when generating an identifier format for resource ``Foo``, the controller generates the stand-alone formats, ``<name>+<choice>`` for ``Foo`` and ``<fk.name>+<fk.choice>`` for ``Bar``, then combine them together to be ``<name>+<choice>++<fk.name>+<fk.choice>``."
msgstr "上記の例では、リソース ``Foo`` の識別子フォーマットを生成する際に、コントローラーは ``Foo`` には ``<name>+<choice>``、``Bar`` には ``<fk.name>+<fk.choice>`` というスタンドアロンフォーマットを生成し、それらを結合して ``<name>+<choice>++<fk.name>+<fk.choice>`` とします。"

#: ../../source/access_resources.rst:81
msgid "When generating identifiers according to the given identifier format, there are cases where a foreign key may point to nowhere. In this case, the controller substitutes the part of the format corresponding to the resource the foreign key should point to with an empty string ''. For example, if a ``Foo`` object has the name ='alice', choice ='yes', but ``fk`` field = None, its resulting identifier will be ``alice+yes++``."
msgstr "指定した識別子フォーマットに従って識別子を生成する際には、外部キーが何も指さない場合があります。この場合、コントローラーは、外部キーが本来指定すべきリソースに対応しているフォーマットの部分を空の文字列 '' で代用します。たとえば、``Foo`` オブジェクトに name = 'alice'、choice = 'yes' があるものの、``fk`` field = None の場合、生成される識別子は ``alice+yes++`` となります。"
